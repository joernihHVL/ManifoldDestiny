---
title: ""
output: github_document
always_allow_html: true
execute: 
  cache: false
filters:
  - webr
---

# Manifold Destiny - or how to rig an election
**Based upon the ideas developed by Edward K. Solomon**
![](pngs/md.png)


```{webr-r}
webr::install("ManifoldDestinyWASMP", repos = "https://lotariohw26.github.io/MD_WASMC")
webr::install("ManifoldDestinyWASMD", repos = "https://lotariohw26.github.io/MD_WASMC")
webr::install("dplyr")
library(ManifoldDestinyWASMP)
ls(package:ManifoldDestinyWASMP)
library(ManifoldDestinyWASMD)
ls(package:ManifoldDestinyWASMD)
```

```{webr-r}
ballcastsim <- function(
	dfm=app0,
	probw=c(0.5,0), 	
	probva=c(0.7,0.2,0.03,0.00), 				
	probvb=c(0.7,0.2,0.03,0.00), 
	ztech=c(0,0)
			){

  # Simulate prob
  probvrnd <<- dfm |>
    dplyr::mutate(ZV=rnorm(dplyr::n(),probw[1],probw[2])) |>
    dplyr::mutate(N=runif(dplyr::n(),ztech[1],ztech[2])) |>
    dplyr::mutate(p3=(1-ztech)*(1-pmax(0, pmin(1,rnorm(dplyr::n(),probva[1],probva[3]))))) |>
    dplyr::mutate(p6=(1-ztech)*(1-pmax(0, pmin(1,rnorm(dplyr::n(),probvb[1],probvb[3]))))) |>
    dplyr::mutate(p2=(1-p3)*pmax(0, pmin(1,rnorm(dplyr::n(),probva[2],probva[4])))) |>
    dplyr::mutate(p5=(1-p6)*pmax(0, pmin(1,rnorm(dplyr::n(),probvb[2],probvb[4])))) |>
    dplyr::mutate(p1=1-p2-p3) |>
    dplyr::mutate(p4=1-p5-p6) |>
    dplyr::select(P,ZV,N,p1,p2,p3,p4,p5,p6)

  #ballcodf <- dfm |> dplyr::left_join(probvrnd,by='P') |> base::split(.$P) |>
  #     purrr::map(function(x){
  ## Assigning voters in each precinct
  #cp <- stats::rbinom(x$R,1,x$ZV) 
  ### Setting up vector frame
  #dc <- data.frame(P=x$P,ZV=x$ZV,R=x$R,C=cp,p1=x$p1,p2=x$p2,p3=x$p3,p4=x$p4,p5=x$p5,p6=x$p6) |>
  #  dplyr::mutate(Id=row_number()) |> 
  #  dplyr::relocate(Id,.before=P)  |>
  #  dplyr::group_by(Id) |> 
  #  dplyr::mutate(V=ifelse(C==1,sample(1:3,1,prob=c(p1,p2,p3)),sample(4:6,1,prob=c(p4,p5,p6)))) |>
  #  dplyr::ungroup() 
  #})  |>
  #dplyr::bind_rows(.) |>
  #dplyr::mutate(Id=row_number(P)) |> 
  #dplyr::relocate(Id,.before=P) |> 
  #dplyr::mutate(S=ifelse(V==1,1,0)) |> 
  #dplyr::mutate(T=ifelse(V==4,1,0)) |>  
  #dplyr::mutate(U=ifelse(V==2,1,0)) |>
  #dplyr::mutate(V=ifelse(V==5,1,0)) |>
  #dplyr::arrange(P) |>  dplyr::group_by(P)  |> 
  #dplyr::select(c('P','R','S','T','U','V')) |>
  #dplyr::mutate(S=sum(S),T=sum(T),U=sum(U),V=sum(V)) |>
  #dplyr::distinct() |> 
  #dplyr::mutate(Z=sum(S+T+U+V)) |>
  #dplyr::ungroup() 
}
print(ballcastsim())
```

```{r, echo=F}
knitr::knit_exit()
```

[From Bard:](https://g.co/bard/share/37bfadf733c5)

Published July 22, 2023 at 05:37 AM

> The first problem is that the proportion of votes cast by mail (w) is nearly constant across all precincts. This is not what we would expect to see in a fair election, where the proportion of votes cast by mail would vary depending on the demographics of the precinct. For example, we would expect to see a higher proportion of votes cast by mail in precincts with a higher population of elderly people.

> The second problem is that we can calculate D knowing only K and A. This is also not possible in a fair election, as D should be determined by the number of ballots cast by mail, which is not known until after all ballots have been cast.

> The third problem is that n decreases rapidly over the quantiles of z, meaning that Democrats are more likely to cast their ballots by mail as Republicans perform better overall. This is not what we would expect to see in a fair election, as we would expect the proportion of Democrats and Republicans who vote by mail to be relatively constant.

> The fourth problem is that the difference between x and y diverges rapidly over the quantiles of z, meaning that as Republican do better in the early vote, the more they suffer in the mail-in vote. This is also not what we would expect to see in a fair election, as we would expect the two types of votes to be relatively correlated.


```{webr-r}
webr::install("ManifoldDestinyWASM", repos = "https://lotariohw26.github.io/ManifoldDestinyWASM/repo")
library(ManifoldDestinyWASM)
ls(package:ManifoldDestinyWASM)
```

